From ed9b7b2fb9333d19789afe4204ed176eecbb31f6 Mon Sep 17 00:00:00 2001
From: Flameshot <dragosgirip@yahoo.com>
Date: Fri, 19 Jun 2015 14:36:18 +0300
Subject: Implemented Arena Spectator
 
*Update code for last TrinityCore Commit
*Added 5 vs 5 Spectate
*Credits Flameshot/Lillecarl and for who had the idea of Arena Spectator
---
 src/server/game/Accounts/RBAC.h                    |   7 +
 src/server/game/Battlegrounds/Battleground.cpp     |  24 +-
 src/server/game/Battlegrounds/Battleground.h       |  11 +
 src/server/game/Battlegrounds/BattlegroundMgr.h    |  11 +-
 src/server/game/Battlegrounds/SpectatorAddon.cpp   | 221 +++++++
 src/server/game/Battlegrounds/SpectatorAddon.h     |  96 +++
 src/server/game/Entities/GameObject/GameObject.cpp |  10 +
 src/server/game/Entities/Player/Player.cpp         | 131 ++++-
 src/server/game/Entities/Player/Player.h           |  16 +-
 src/server/game/Entities/Unit/Unit.cpp             |  13 +
 src/server/game/Handlers/ChatHandler.cpp           |   6 +
 src/server/game/Maps/Map.cpp                       |   7 +
 src/server/game/Miscellaneous/Language.h           |   3 +
 src/server/game/Scripting/ScriptLoader.cpp         |   2 +
 src/server/game/Spells/Spell.cpp                   |   4 +
 src/server/scripts/Commands/cs_gm.cpp              |   3 +
 src/server/scripts/Custom/ArenaSpectator/README.md |  34 ++
 .../Custom/ArenaSpectator/arena_spectator.cpp      | 642 +++++++++++++++++++++
 .../ArenaSpectator/sql/Arena Spectator NPC.sql     |  10 +
 .../ArenaSpectator/sql/rbac_linked_permissions.sql |   6 +
 .../Custom/ArenaSpectator/sql/rbac_permissions.sql |   6 +
 src/server/scripts/Custom/CMakeLists.txt           |   3 +-
 22 files changed, 1249 insertions(+), 17 deletions(-)
 create mode 100644 src/server/game/Battlegrounds/SpectatorAddon.cpp
 create mode 100644 src/server/game/Battlegrounds/SpectatorAddon.h
 create mode 100644 src/server/scripts/Custom/ArenaSpectator/README.md
 create mode 100644 src/server/scripts/Custom/ArenaSpectator/arena_spectator.cpp
 create mode 100644 src/server/scripts/Custom/ArenaSpectator/sql/Arena Spectator NPC.sql
 create mode 100644 src/server/scripts/Custom/ArenaSpectator/sql/rbac_linked_permissions.sql
 create mode 100644 src/server/scripts/Custom/ArenaSpectator/sql/rbac_permissions.sql
 
diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index 339788d..3123723 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -694,6 +694,13 @@ enum RBACPermissions
     RBAC_PERM_COMMAND_INSTANCE_GET_BOSS_STATE                = 796,
     RBAC_PERM_COMMAND_PVPSTATS                               = 797,
     RBAC_PERM_COMMAND_MODIFY_XP                              = 798,
+      
+       //Arena Spectator
+    RBAC_PERM_COMMAND_SPECTATE                               = 1003,
+    RBAC_PERM_COMMAND_SPECTATE_PLAYER                        = 1004,
+    RBAC_PERM_COMMAND_SPECTATE_VIEW                          = 1005,
+    RBAC_PERM_COMMAND_SPECTATE_RESET                         = 1006,
+    RBAC_PERM_COMMAND_SPECTATE_LEAVE                         = 1007,
 
     // custom permissions 1000+
     RBAC_PERM_MAX
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index 3e9b68d..3dce38c 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -1128,13 +1128,23 @@ void Battleground::EventPlayerLoggedOut(Player* player)
     m_Players[guid].OfflineRemoveTime = sWorld->GetGameTime() + MAX_OFFLINE_TIME;
     if (GetStatus() == STATUS_IN_PROGRESS)
     {
-        // drop flag and handle other cleanups
-        RemovePlayer(player, guid, GetPlayerTeam(guid));
-
-        // 1 player is logging out, if it is the last, then end arena!
-        if (isArena())
-            if (GetAlivePlayersCountByTeam(player->GetBGTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetBGTeam())))
-                EndBattleground(GetOtherTeam(player->GetBGTeam()));
+        if (!player->IsSpectator())
+        {
+            // drop flag and handle other cleanups
+            RemovePlayer(player, guid, GetPlayerTeam(guid));
+            // 1 player is logging out, if it is the last, then end arena!
+            if (isArena())
+                if (GetAlivePlayersCountByTeam(player->GetTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetTeam())))
+                    EndBattleground(GetOtherTeam(player->GetTeam()));
+        }
+    }
+          
+       if (!player->IsSpectator())
+        player->LeaveBattleground();
+    else
+    {
+        player->TeleportToBGEntryPoint();
+        RemoveSpectator(player->GetGUID());
     }
 }
 
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index 562a20b..3cb081a 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -26,6 +26,7 @@
 #include "WorldPacket.h"
 #include "Object.h"
 #include "GameObject.h"
+#include "SpectatorAddon.h"
 
 class Creature;
 class GameObject;
@@ -299,6 +300,13 @@ class Battleground
         uint32 GetInvitedCount(uint32 team) const   { return (team == ALLIANCE) ? m_InvitedAlliance : m_InvitedHorde; }
         bool HasFreeSlots() const;
         uint32 GetFreeSlotsForTeam(uint32 Team) const;
+              
+               /* Arena Spectator */
+               typedef std::set<uint32> SpectatorList;
+               void AddSpectator(uint32 playerId) { m_Spectators.insert(playerId); }
+               void RemoveSpectator(uint32 playerId) { m_Spectators.erase(playerId); }
+               bool HaveSpectators() { return (m_Spectators.size() > 0); }
+               /* Arena Spectator */
 
         bool isArena() const        { return m_IsArena; }
         bool isBattleground() const { return !m_IsArena; }
@@ -577,6 +585,9 @@ class Battleground
         // Raid Group
         Group* m_BgRaids[BG_TEAMS_COUNT];                   // 0 - alliance, 1 - horde
 
+        // Arena Spectator
+        SpectatorList m_Spectators;
+
         // Players count by team
         uint32 m_PlayersCount[BG_TEAMS_COUNT];
 
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.h b/src/server/game/Battlegrounds/BattlegroundMgr.h
index f732f43..12143cb 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.h
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.h
@@ -109,6 +109,8 @@ class BattlegroundMgr
 
         bool isArenaTesting() const { return m_ArenaTesting; }
         bool isTesting() const { return m_Testing; }
+              
+               bool IsArenaType(BattlegroundTypeId bgTypeId);
 
         static BattlegroundQueueTypeId BGQueueTypeId(BattlegroundTypeId bgTypeId, uint8 arenaType);
         static BattlegroundTypeId BGTemplateId(BattlegroundQueueTypeId bgQueueTypeId);
@@ -117,6 +119,14 @@ class BattlegroundMgr
         static HolidayIds BGTypeToWeekendHolidayId(BattlegroundTypeId bgTypeId);
         static BattlegroundTypeId WeekendHolidayIdToBGType(HolidayIds holiday);
         static bool IsBGWeekend(BattlegroundTypeId bgTypeId);
+               BattlegroundData* GetAllBattlegroundsWithTypeId(BattlegroundTypeId bgTypeId)
+        {
+            BattlegroundDataContainer::iterator it = bgDataStore.find(bgTypeId);
+            if (it == bgDataStore.end())
+                return NULL;
+
+            return &it->second;
+        }
 
         uint32 GetMaxRatingDifference() const;
         uint32 GetRatingDiscardTimer()  const;
@@ -134,7 +144,6 @@ class BattlegroundMgr
     private:
         bool CreateBattleground(BattlegroundTemplate const* bgTemplate);
         uint32 CreateClientVisibleInstanceId(BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id);
-        static bool IsArenaType(BattlegroundTypeId bgTypeId);
         BattlegroundTypeId GetRandomBG(BattlegroundTypeId id);
 
         typedef std::map<BattlegroundTypeId, BattlegroundData> BattlegroundDataContainer;
diff --git a/src/server/game/Battlegrounds/SpectatorAddon.cpp b/src/server/game/Battlegrounds/SpectatorAddon.cpp
new file mode 100644
index 0000000..39ce7dd
--- /dev/null
+++ b/src/server/game/Battlegrounds/SpectatorAddon.cpp
@@ -0,0 +1,221 @@
+/*
+* Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "ScriptPCH.h"
+#include "Player.h"
+#include "Item.h"
+#include "SpellInfo.h"
+#include "SpectatorAddon.h"
+
+SpectatorAddonMsg::SpectatorAddonMsg()
+{
+    for (uint8 i = 0; i < SPECTATOR_PREFIX_COUNT; ++i)
+        prefixFlags[i] = false;
+
+    player = "";
+    target = "";
+    isAlive = false;
+    pClass = CLASS_WARRIOR;
+    maxHP = 0;
+    maxPower = 0;
+    currHP = 0;
+    currPower = 0;
+    powerType = POWER_MANA;
+    spellId = 0;
+    castTime = 0;
+    team = ALLIANCE;
+}
+
+bool SpectatorAddonMsg::CanSandAura(uint32 auraID)
+{
+    const SpellInfo *spell = sSpellMgr->GetSpellInfo(auraID);
+    if (!spell)
+        return false;
+
+    if (spell->SpellIconID == 1)
+        return false;
+
+    return true;
+}
+
+void SpectatorAddonMsg::CreateAura(uint32 _caster, uint32 _spellId, bool _isDebuff, uint8 _type, int32 _duration, int32 _expire, uint16 _stack, bool _isRemove)
+{
+    if (!CanSandAura(_spellId))
+        return;
+
+    aCaster = _caster;
+    aSpellId = _spellId;
+    aIsDebuff = _isDebuff;
+    aType = _type;
+    aDuration = _duration;
+    aExpire = _expire;
+    aStack = _stack;
+    aRemove = _isRemove;
+    EnableFlag(SPECTATOR_PREFIX_AURA);
+}
+
+std::string SpectatorAddonMsg::GetMsgData()
+{
+    std::string addonData = "";
+
+    if (!isFilledIn(SPECTATOR_PREFIX_PLAYER))
+    {
+        TC_LOG_INFO("battleground", "SPECTATOR ADDON: player is not filled in.");
+        return addonData;
+    }
+
+    std::string msg = "";
+    for (uint8 i = 0; i < SPECTATOR_PREFIX_COUNT; ++i)
+        if (isFilledIn(i))
+        {
+            switch (i)
+            {
+            case SPECTATOR_PREFIX_PLAYER:
+                msg += player + ";";
+                break;
+            case SPECTATOR_PREFIX_TARGET:
+                msg += "TRG=" + target + ";";
+                break;
+            case SPECTATOR_PREFIX_TEAM:
+            {
+                char buffer[20];
+                sprintf(buffer, "TEM=%i;", (uint16)team);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_STATUS:
+            {
+                char buffer[20];
+                sprintf(buffer, "STA=%d;", isAlive);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_CLASS:
+            {
+                char buffer[20];
+                sprintf(buffer, "CLA=%i;", (int)pClass);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_MAXHP:
+            {
+                char buffer[30];
+                sprintf(buffer, "MHP=%i;", maxHP);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_CURHP:
+            {
+                char buffer[30];
+                sprintf(buffer, "CHP=%i;", currHP);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_MAXPOWER:
+            {
+                char buffer[30];
+                sprintf(buffer, "MPW=%i;", maxPower);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_CURPOWER:
+            {
+                char buffer[30];
+                sprintf(buffer, "CPW=%i;", currPower);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_POWERTYPE:
+            {
+                char buffer[20];
+                sprintf(buffer, "PWT=%i;", (uint8)powerType);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_SPELL:
+            {
+                char buffer[80];
+                sprintf(buffer, "SPE=%i,%i;", spellId, castTime);
+                msg += buffer;
+                break;
+            }
+            case SPECTATOR_PREFIX_AURA:
+            {
+                char buffer[300];
+                sprintf(buffer, "AUR=%i,%i,%i,%i,%i,%i,%i,0x%X;", aRemove, aStack,
+                    aExpire, aDuration,
+                    aSpellId, aType,
+                    aIsDebuff, aCaster);
+                msg += buffer;
+                break;
+            }
+            }
+        }
+
+    if (msg != "")
+        addonData = "ARENASPEC " + msg;
+
+    return addonData;
+}
+
+bool SpectatorAddonMsg::SendPacket(ObjectGuid receiver)
+{
+    std::string addonData = GetMsgData();
+    if (addonData == "")
+        return false;
+
+    Player* rPlayer = ObjectAccessor::FindPlayer(receiver);
+    if (!rPlayer)
+        return false;
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << uint8(CHAT_MSG_WHISPER);
+    data << uint32(LANG_ADDON);
+    data << uint64(0);
+    data << uint32(LANG_ADDON);                               //language 2.1.0 ?
+    data << uint64(0);
+    data << uint32(addonData.length() + 1);
+    data << addonData;
+    data << uint8(CHAT_TAG_NONE);
+    rPlayer->GetSession()->SendPacket(&data);
+
+    return true;
+}
+
+bool SpectatorAddonMsg::SendPacket(SpectatorAddonMsg msg, ObjectGuid receiver)
+{
+    std::string addonData = msg.GetMsgData();
+    if (addonData == "")
+        return false;
+
+    Player* rPlayer = ObjectAccessor::FindPlayer(receiver);
+    if (!rPlayer)
+        return false;
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << uint8(CHAT_MSG_WHISPER);
+    data << uint32(LANG_ADDON);
+    data << uint64(0);
+    data << uint32(LANG_ADDON);                               //language 2.1.0 ?
+    data << uint64(0);
+    data << uint32(addonData.length() + 1);
+    data << addonData;
+    data << uint8(CHAT_TAG_NONE);
+    rPlayer->GetSession()->SendPacket(&data);
+
+    return true;
+}
\ No newline at end of file
diff --git a/src/server/game/Battlegrounds/SpectatorAddon.h b/src/server/game/Battlegrounds/SpectatorAddon.h
new file mode 100644
index 0000000..21f44c4
--- /dev/null
+++ b/src/server/game/Battlegrounds/SpectatorAddon.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define SPECTATOR_ADDON_SPELL_INTERUPTED 99999 // specific addons
+#define SPECTATOR_ADDON_SPELL_CANCELED 99998   // numbers =\
+
+
+enum SpectatorPrefix {
+       SPECTATOR_PREFIX_PLAYER,
+       SPECTATOR_PREFIX_STATUS,
+       SPECTATOR_PREFIX_MAXHP,
+       SPECTATOR_PREFIX_CURHP,
+       SPECTATOR_PREFIX_MAXPOWER,
+       SPECTATOR_PREFIX_CURPOWER,
+       SPECTATOR_PREFIX_POWERTYPE,
+       SPECTATOR_PREFIX_TARGET,
+       SPECTATOR_PREFIX_CLASS,
+       SPECTATOR_PREFIX_TEAM,
+       SPECTATOR_PREFIX_SPELL,
+       SPECTATOR_PREFIX_AURA,
+       SPECTATOR_PREFIX_COUNT      // must be at the end of list
+};
+
+class SpectatorAddonMsg {
+    public:
+        SpectatorAddonMsg();
+
+        void SetPlayer(std::string _player)     { player    = _player;  EnableFlag(SPECTATOR_PREFIX_PLAYER); }
+        void SetStatus(bool _isAlive)           { isAlive   = _isAlive; EnableFlag(SPECTATOR_PREFIX_STATUS); }
+        void SetClass(uint8 _class)             { pClass    = _class;   EnableFlag(SPECTATOR_PREFIX_CLASS); }
+        void SetTarget(std::string _target)     { target    = _target;  EnableFlag(SPECTATOR_PREFIX_TARGET); }
+        void SetTeam(uint32 _team)              { team      = _team;    EnableFlag(SPECTATOR_PREFIX_TEAM); }
+
+        void SetMaxHP(uint16 hp)                { maxHP     = hp; EnableFlag(SPECTATOR_PREFIX_MAXHP); }
+        void SetCurrentHP(uint16 hp)            { currHP    = hp; EnableFlag(SPECTATOR_PREFIX_CURHP);  }
+        void SetMaxPower(uint16 power)          { maxPower  = power; EnableFlag(SPECTATOR_PREFIX_MAXPOWER); }
+        void SetCurrentPower(uint16 power)      { currPower = power; EnableFlag(SPECTATOR_PREFIX_CURPOWER); }
+        void SetPowerType(Powers power)         { powerType = power; EnableFlag(SPECTATOR_PREFIX_POWERTYPE); }
+
+        void CastSpell(uint32 _spellId, uint32 _castTime) { spellId = _spellId; castTime = _castTime; EnableFlag(SPECTATOR_PREFIX_SPELL); }
+        void CreateAura(uint32 _caster,  uint32 _spellId, bool _isDebuff, uint8 _type, int32 _duration, int32 _expire, uint16 _stack, bool _isRemove);
+
+        static bool SendPacket(SpectatorAddonMsg msg, ObjectGuid receiver);
+        bool SendPacket(ObjectGuid receiver);
+
+        std::string GetMsgData();
+
+        bool isFilledIn(uint8 prefix) { return prefixFlags[prefix]; }
+
+        static bool CanSandAura(uint32 auraID);
+    private:
+
+        void EnableFlag(uint8 prefix) { prefixFlags[prefix] = true; }
+        std::string player;
+        bool isAlive;
+        std::string target;
+        uint8 pClass;
+
+        uint16 maxHP;
+        uint16 maxPower;
+        uint16 currHP;
+        uint16 currPower;
+        Powers powerType;
+
+        uint32 spellId;
+        uint32 castTime;
+
+        uint32 team;
+
+        // aura data
+        uint32 aCaster;
+        uint32 aSpellId;
+        bool aIsDebuff;
+        uint8 aType;
+        int32 aDuration;
+        int32 aExpire;
+        uint16 aStack;
+        bool aRemove;
+
+        bool prefixFlags[SPECTATOR_PREFIX_COUNT];
+};
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index a4b140b..c3833ed 100644
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -564,6 +564,11 @@ void GameObject::Update(uint32 diff)
                     }
                     else if (Unit* target = ObjectAccessor::GetUnit(*this, m_lootStateUnitGUID))
                     {
+                                            // If player is spectator do not activate.
+                                               if (Player *tmpPlayer = target->ToPlayer())
+                            if (tmpPlayer->IsSpectator())
+                                return;
+
                         // Some traps do not have a spell but should be triggered
                         if (goInfo->trap.spellId)
                             CastSpell(target, goInfo->trap.spellId);
@@ -1765,6 +1770,11 @@ void GameObject::Use(Unit* user)
 
 void GameObject::CastSpell(Unit* target, uint32 spellId, bool triggered /*= true*/)
 {
+       if (target)
+        if (Player *tmpPlayer = target->ToPlayer())
+            if (tmpPlayer->IsSpectator())
+                return;
+
     SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
     if (!spellInfo)
         return;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 275dbf9..157d11c 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -901,8 +901,13 @@ Player::Player(WorldSession* session): Unit(true)
     m_MonthlyQuestChanged = false;
 
     m_SeasonalQuestChanged = false;
-
-    SetPendingBind(0, 0);
+      
+        // Arena Spectator
+       spectatorFlag = false;
+       spectateCanceled = false;
+       spectateFrom = NULL;
+    
+       SetPendingBind(0, 0);
 
     _activeCheats = CHEAT_NONE;
     m_achievementMgr = new AchievementMgr(this);
@@ -2395,7 +2400,16 @@ bool Player::TeleportToBGEntryPoint()
     ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
     ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
     ScheduleDelayedOperation(DELAYED_BG_GROUP_RESTORE);
-    return TeleportTo(m_bgData.joinPos);
+    Battleground *oldBg = GetBattleground();
+    bool result = TeleportTo(m_bgData.joinPos);
+
+    if (IsSpectator() && result)
+    {
+        SetSpectate(false);
+        if (oldBg)
+            oldBg->RemoveSpectator(GetGUID());
+    }
+    return result;
 }
 
 void Player::ProcessDelayedOperations()
@@ -24100,6 +24114,15 @@ void Player::SetViewpoint(WorldObject* target, bool apply)
 {
     if (apply)
     {
+           if (target->ToPlayer() == this)
+            return;
+
+        //remove Viewpoint if already have
+        if (IsSpectator() && spectateFrom)
+        {
+            SetViewpoint(spectateFrom, false);
+            spectateFrom = NULL;
+        }
         TC_LOG_DEBUG("maps", "Player::CreateViewpoint: Player %s create seer %u (TypeId: %u).", GetName().c_str(), target->GetEntry(), target->GetTypeId());
 
         if (!AddGuidValue(PLAYER_FARSIGHT, target->GetGUID()))
@@ -24111,11 +24134,19 @@ void Player::SetViewpoint(WorldObject* target, bool apply)
         // farsight dynobj or puppet may be very far away
         UpdateVisibilityOf(target);
 
-        if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
-            ((Unit*)target)->AddPlayerToVision(this);
-    }
+               if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
+               {
+                       if (IsSpectator())
+                               spectateFrom = (Unit*)target;
+
+                       ((Unit*)target)->AddPlayerToVision(this);
+               }        
+   }
     else
     {
+           if (IsSpectator() && !spectateFrom)
+            return;
+                      
         TC_LOG_DEBUG("maps", "Player::CreateViewpoint: Player %s remove seer", GetName().c_str());
 
         if (!RemoveGuidValue(PLAYER_FARSIGHT, target->GetGUID()))
@@ -24129,6 +24160,9 @@ void Player::SetViewpoint(WorldObject* target, bool apply)
 
         //must immediately set seer back otherwise may crash
         m_seer = this;
+              
+               if (IsSpectator())
+            spectateFrom = NULL;
 
         //WorldPacket data(SMSG_CLEAR_FAR_SIGHT_IMMEDIATE, 0);
         //GetSession()->SendPacket(&data);
@@ -26557,3 +26591,88 @@ bool Player::ValidateAppearance(uint8 race, uint8 class_, uint8 gender, uint8 ha
 
     return true;
 }
+
+void Player::SetSelection(ObjectGuid guid)
+{
+    uint32 m_curSelection = guid;
+    SetUInt64Value(UNIT_FIELD_TARGET, guid);
+}
+
+void Player::SetSpectate(bool on)
+{
+    if (on)
+    {
+        SetSpeed(MOVE_RUN, 5.0);
+        spectatorFlag = true;
+
+        m_ExtraFlags |= PLAYER_EXTRA_GM_ON;
+        setFaction(35);
+
+        if (Pet* pet = GetPet())
+        {
+            RemovePet(pet, PET_SAVE_AS_CURRENT);
+        }
+        UnsummonPetTemporaryIfAny();
+
+        RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+        ResetContestedPvP();
+
+        getHostileRefManager().setOnlineOfflineState(false);
+        CombatStopWithPets();
+
+        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_ADMINISTRATOR);
+    }
+    else
+    {
+        uint32 newPhase = 0;
+        AuraEffectList const& phases = GetAuraEffectsByType(SPELL_AURA_PHASE);
+        if (!phases.empty())
+            for (AuraEffectList::const_iterator itr = phases.begin(); itr != phases.end(); ++itr)
+                newPhase |= (*itr)->GetMiscValue();
+
+        if (!newPhase)
+            newPhase = PHASEMASK_NORMAL;
+
+        SetPhaseMask(newPhase, false);
+
+        m_ExtraFlags &= ~ PLAYER_EXTRA_GM_ON;
+        setFactionForRace(getRace());
+        RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_GM);
+        RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);
+
+        if (spectateFrom)
+            SetViewpoint(spectateFrom, false);
+
+        // restore FFA PvP Server state
+        if (sWorld->IsFFAPvPRealm())
+            SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+
+        // restore FFA PvP area state, remove not allowed for GM mounts
+        UpdateArea(m_areaUpdateId);
+
+        getHostileRefManager().setOnlineOfflineState(true);
+        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
+        spectateCanceled = false;
+        spectatorFlag = false;
+        RestoreDisplayId();
+        UpdateSpeed(MOVE_RUN, true);
+    }
+    UpdateObjectVisibility();
+}
+
+bool Player::HaveSpectators()
+{
+    if (IsSpectator())
+        return false;
+
+    if (Battleground *bg = GetBattleground())
+        if (bg->isArena())
+        {
+            if (bg->GetStatus() != STATUS_IN_PROGRESS)
+                return false;
+
+            return bg->HaveSpectators();
+        }
+
+        return false;
+}
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 98b9d8a..50de4e7 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -1155,7 +1155,7 @@ class Player : public Unit, public GridObject<Player>
                                                             // mount_id can be used in scripting calls
         bool isAcceptWhispers() const { return (m_ExtraFlags & PLAYER_EXTRA_ACCEPT_WHISPERS) != 0; }
         void SetAcceptWhispers(bool on) { if (on) m_ExtraFlags |= PLAYER_EXTRA_ACCEPT_WHISPERS; else m_ExtraFlags &= ~PLAYER_EXTRA_ACCEPT_WHISPERS; }
-        bool IsGameMaster() const { return (m_ExtraFlags & PLAYER_EXTRA_GM_ON) != 0; }
+        bool IsGameMaster() const { return (m_ExtraFlags & PLAYER_EXTRA_GM_ON); }
         void SetGameMaster(bool on);
         bool isGMChat() const { return (m_ExtraFlags & PLAYER_EXTRA_GM_CHAT) != 0; }
         void SetGMChat(bool on) { if (on) m_ExtraFlags |= PLAYER_EXTRA_GM_CHAT; else m_ExtraFlags &= ~PLAYER_EXTRA_GM_CHAT; }
@@ -1166,6 +1166,14 @@ class Player : public Unit, public GridObject<Player>
         bool Has310Flyer(bool checkAllSpells, uint32 excludeSpellId = 0);
         void SetHas310Flyer(bool on) { if (on) m_ExtraFlags |= PLAYER_EXTRA_HAS_310_FLYER; else m_ExtraFlags &= ~PLAYER_EXTRA_HAS_310_FLYER; }
         void SetPvPDeath(bool on) { if (on) m_ExtraFlags |= PLAYER_EXTRA_PVP_DEATH; else m_ExtraFlags &= ~PLAYER_EXTRA_PVP_DEATH; }
+              
+               // Arena Spectator
+               bool HaveSpectators();
+        bool isSpectateCanceled() { return spectateCanceled; }
+        void CancelSpectate() { spectateCanceled = true; }
+        Unit* getSpectateFrom() { return spectateFrom; }
+        bool IsSpectator() const { return spectatorFlag; }
+        void SetSpectate(bool on);
 
         void GiveXP(uint32 xp, Unit* victim, float group_rate=1.0f);
         void GiveLevel(uint8 level);
@@ -1540,7 +1548,7 @@ class Player : public Unit, public GridObject<Player>
         Player* GetSelectedPlayer() const;
 
         void SetTarget(ObjectGuid /*guid*/) override { } /// Used for serverside target changes, does not apply to players
-        void SetSelection(ObjectGuid guid) { SetGuidValue(UNIT_FIELD_TARGET, guid); }
+        void SetSelection(ObjectGuid guid);
 
         uint8 GetComboPoints() const { return m_comboPoints; }
         ObjectGuid GetComboTarget() const { return m_comboTarget; }
@@ -2640,6 +2648,10 @@ class Player : public Unit, public GridObject<Player>
         InstanceTimeMap _instanceResetTimes;
         uint32 _pendingBindId;
         uint32 _pendingBindTimer;
+              
+           bool spectatorFlag;
+        bool spectateCanceled;
+        Unit *spectateFrom;
 
         uint32 _activeCheats;
 };
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 9b0da57..fed1ef2 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -268,6 +268,19 @@ Unit::~Unit()
             m_currentSpells[i]->SetReferencedFromCurrent(false);
             m_currentSpells[i] = NULL;
         }
+              
+               // remove view point for spectator
+        if (!m_sharedVision.empty())
+        {
+            for (SharedVisionList::iterator itr = m_sharedVision.begin(); itr != m_sharedVision.end(); ++itr)
+                if ((*itr)->IsSpectator() && (*itr)->getSpectateFrom())
+                {
+                    (*itr)->SetViewpoint((*itr)->getSpectateFrom(), false);
+                    if (m_sharedVision.empty())
+                        break;
+                    --itr;
+                }
+        }
 
     _DeleteRemovedAuras();
 
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index 2acbaba..60aef83 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -551,6 +551,12 @@ void WorldSession::HandleTextEmoteOpcode(WorldPacket& recvData)
     recvData >> text_emote;
     recvData >> emoteNum;
     recvData >> guid;
+      
+       if (GetPlayer()->IsSpectator())
+    {
+        SendNotification(LANG_SPEC_CAN_NOT_CHAT);
+        return;
+    }
 
     sScriptMgr->OnPlayerTextEmote(GetPlayer(), text_emote, emoteNum, guid);
 
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index c1a4624..71f5ea0 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -3267,6 +3267,13 @@ bool BattlegroundMap::AddPlayerToMap(Player* player)
 
 void BattlegroundMap::RemovePlayerFromMap(Player* player, bool remove)
 {
+       if (player && player->IsSpectator() && !player->isSpectateCanceled())
+    {
+        if (GetBG())
+            GetBG()->RemoveSpectator(player->GetGUID());
+        player->SetSpectate(false);
+    }
+      
     TC_LOG_DEBUG("maps", "MAP: Removing player '%s' from bg '%u' of map '%s' before relocating to another map", player->GetName().c_str(), GetInstanceId(), GetMapName());
     Map::RemovePlayerFromMap(player, remove);
 }
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index 9bae8fb..dcf9dea 100644
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -853,6 +853,9 @@ enum TrinityStrings
     LANG_ACCOUNT_SEC_TYPE               = 880,
     LANG_RBAC_EMAIL_REQUIRED            = 881,
     // Room for in-game strings           882-999 not used
+      
+       // Arena Spectator
+    LANG_SPEC_CAN_NOT_CHAT = 900,
 
     // Level 4 (CLI only commands)
     LANG_COMMAND_EXIT                   = 1000,
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index f0ee013..724df1c 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1417,6 +1417,7 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
+void AddSC_arena_spectator_script();
 
 #endif
 
@@ -1424,6 +1425,7 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
+       AddSC_arena_spectator_script();
 
 #endif
 }
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index ff7c6a8..8eccc60 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -4661,6 +4661,10 @@ SpellCastResult Spell::CheckCast(bool strict)
                 m_caster->GetMap()->IsOutdoors(m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ()))
             return SPELL_FAILED_ONLY_INDOORS;
     }
+      
+       if (Player *tmpPlayer = m_caster->ToPlayer())
+        if (tmpPlayer->IsSpectator())
+            return SPELL_FAILED_SPELL_UNAVAILABLE;
 
     // only check at first call, Stealth auras are already removed at second call
     // for now, ignore triggered spells
diff --git a/src/server/scripts/Commands/cs_gm.cpp b/src/server/scripts/Commands/cs_gm.cpp
index 94e974b..24e48f7 100644
--- a/src/server/scripts/Commands/cs_gm.cpp
+++ b/src/server/scripts/Commands/cs_gm.cpp
@@ -133,6 +133,9 @@ public:
                  itrSec <= AccountTypes(sWorld->getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
                 (!handler->GetSession() || itr->second->IsVisibleGloballyFor(handler->GetSession()->GetPlayer())))
             {
+                               if (itr->second->IsSpectator())
+                                       continue; // don't show spectators, they're not really gms
+                                      
                 if (first)
                 {
                     first = false;
diff --git a/src/server/scripts/Custom/ArenaSpectator/README.md b/src/server/scripts/Custom/ArenaSpectator/README.md
new file mode 100644
index 0000000..fdc42f0
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaSpectator/README.md
@@ -0,0 +1,34 @@
+#Arena Spectator
+
+####About
+Arena Spectator gives you the
+oportunity to spectate players when
+they are in arena.You can spectate a
+2vs2 / 3vs3 / 5vs5 / Specific Player arena.
+
+
+####Installation
+
+Available as:
+- Direct merge: https://github.com/Flameshot/TrinityCore/tree/Arena-Spectator
+- Diff:
+- Patch:
+
+Using direct merge:
+- open git bash to source location
+- do `git remote add flameshot https://github.com/Flameshot/TrinityCore.git`
+- do `git pull flameshot Arena-Spectator`
+- use cmake and compile
+
+Using diff:
+- download the diff by __right clicking__ the link and select __Save link as__
+- place the downloaded `arena-spectator.diff` to the source root folder
+- open git bash to source location
+- do `git apply arena-spectator.diff`
+- use cmake and compile
+
+After compiling:
+- Navigate to `\src\server\scripts\Custom\ArenaSpectator\sql\`
+- Run `Arena Spectator NPC.sql` to your world database
+- Run `rbac_linked_permissions.sql` to your auth database
+- Run `rbac_permissions.sql` to your auth database
diff --git a/src/server/scripts/Custom/ArenaSpectator/arena_spectator.cpp b/src/server/scripts/Custom/ArenaSpectator/arena_spectator.cpp
new file mode 100644
index 0000000..38aa52b
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaSpectator/arena_spectator.cpp
@@ -0,0 +1,642 @@
+/*
+* Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+* Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/* ScriptData
+Name: Arena Spectator
+Comment: Script allow spectate arena games
+Category: Custom Script
+Credits: Flameshot/Lillecarl
+EndScriptData */
+
+#include "ScriptPCH.h"
+#include "Chat.h"
+#include "ArenaTeamMgr.h"
+#include "BattlegroundMgr.h"
+#include "WorldSession.h"
+#include "Player.h"
+#include "ArenaTeam.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "CreatureTextMgr.h"
+#include "Config.h"
+
+int8 UsingGossip;
+
+class arena_spectator_commands : public CommandScript
+{
+public:
+       arena_spectator_commands() : CommandScript("arena_spectator_commands") { }
+
+       static bool HandleSpectateCommand(ChatHandler* handler, char const* args)
+       {
+               Player* target;
+               ObjectGuid target_guid;
+               std::string target_name;
+               if (!handler->extractPlayerTarget((char*)args, &target, &target_guid, &target_name))
+                       return false;
+
+               Player* player = handler->GetSession()->GetPlayer();
+               if (target == player || target_guid == player->GetGUID())
+               {
+                       handler->PSendSysMessage("You can't spectate yourself.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (player->IsInCombat())
+               {
+                       handler->PSendSysMessage("You are in combat.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (!target)
+               {
+                       handler->PSendSysMessage("Target is not online or does not exist.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (player->GetPet())
+               {
+                       handler->PSendSysMessage("You must hide your pet.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (player->GetMap()->IsBattlegroundOrArena() && !player->IsSpectator())
+               {
+                       handler->PSendSysMessage("You are already in a battleground or arena.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               Map* cMap = target->GetMap();
+               if (!cMap->IsBattleArena())
+               {
+                       handler->PSendSysMessage("Player is not in an Arena match.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (player->GetMap()->IsBattleground())
+               {
+                       handler->PSendSysMessage("You can't do that while in a battleground.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (target->HasAura(32728) || target->HasAura(32727))
+               {
+                       handler->PSendSysMessage("You can't do that. The Arena match didn't start yet.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (target->IsSpectator())
+               {
+                       handler->PSendSysMessage("You can't do that. Your target is a spectator.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (player->IsMounted())
+               {
+                       handler->PSendSysMessage("Cannot Spectate while mounted.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               // all's well, set bg id
+               // when porting out from the bg, it will be reset to 0
+               player->SetBattlegroundId(target->GetBattlegroundId(), target->GetBattlegroundTypeId());
+               // remember current position as entry point for return at bg end teleportation
+               if (!player->GetMap()->IsBattlegroundOrArena())
+                       player->SetBattlegroundEntryPoint();
+
+               // stop flight if need
+               if (player->IsInFlight())
+               {
+                       player->GetMotionMaster()->MovementExpired();
+                       player->CleanupAfterTaxiFlight();
+               }
+               // save only in non-flight case
+               else
+                       player->SaveRecallPosition();
+
+               // search for two teams
+               Battleground *bGround = target->GetBattleground();
+               if (bGround->isRated())
+               {
+                       uint32 slot = bGround->GetArenaType() - 2;
+                       if (bGround->GetArenaType() > 3)
+                               slot = 2;
+                       uint32 firstTeamID = target->GetArenaTeamId(slot);
+                       uint32 secondTeamID = 0;
+                       Player *firstTeamMember = target;
+                       Player *secondTeamMember = NULL;
+                       for (Battleground::BattlegroundPlayerMap::const_iterator itr = bGround->GetPlayers().begin(); itr != bGround->GetPlayers().end(); ++itr)
+                               if (Player* tmpPlayer = ObjectAccessor::FindPlayer(itr->first))
+                               {
+                                       if (tmpPlayer->IsSpectator())
+                                               continue;
+
+                                       uint32 tmpID = tmpPlayer->GetArenaTeamId(slot);
+                                       if (tmpID != firstTeamID && tmpID > 0)
+                                       {
+                                               secondTeamID = tmpID;
+                                               secondTeamMember = tmpPlayer;
+                                               break;
+                                       }
+                               }
+
+                       if (firstTeamID > 0 && secondTeamID > 0 && secondTeamMember)
+                       {
+                               ArenaTeam *firstTeam = sArenaTeamMgr->GetArenaTeamById(firstTeamID);
+                               ArenaTeam *secondTeam = sArenaTeamMgr->GetArenaTeamById(secondTeamID);
+                               if (firstTeam && secondTeam)
+                               {
+                                       handler->PSendSysMessage("You entered a Rated Arena.");
+                                       handler->PSendSysMessage("Teams:");
+                                       handler->PSendSysMessage("|cFFffffff%s|r vs |cFFffffff%s|r", firstTeam->GetName().c_str(), secondTeam->GetName().c_str());
+                                       handler->PSendSysMessage("|cFFffffff%u(%u)|r -- |cFFffffff%u(%u)|r", firstTeam->GetRating(), firstTeam->GetAverageMMR(firstTeamMember->GetGroup()),
+                                               secondTeam->GetRating(), secondTeam->GetAverageMMR(secondTeamMember->GetGroup()));
+                               }
+                       }
+               }
+
+               // to point to see at target with same orientation
+               float x, y, z;
+               target->GetContactPoint(player, x, y, z);
+
+               player->TeleportTo(target->GetMapId(), x, y, z, player->GetAngle(target), TELE_TO_GM_MODE);
+               player->SetPhaseMask(target->GetPhaseMask(), true);
+               player->SetSpectate(true);
+               target->GetBattleground()->AddSpectator(player->GetGUID());
+
+               return true;
+       }
+
+       static bool HandleSpectateCancelCommand(ChatHandler* handler, const char* /*args*/)
+       {
+               Player* player = handler->GetSession()->GetPlayer();
+
+               if (!player->IsSpectator())
+               {
+                       handler->PSendSysMessage("You are not a spectator.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               player->GetBattleground()->RemoveSpectator(player->GetGUID());
+               player->CancelSpectate();
+               player->TeleportToBGEntryPoint();
+
+               return true;
+       }
+
+       static bool HandleSpectateFromCommand(ChatHandler* handler, const char *args)
+       {
+               Player* target;
+               ObjectGuid target_guid;
+               std::string target_name;
+               if (!handler->extractPlayerTarget((char*)args, &target, &target_guid, &target_name))
+                       return false;
+
+               Player* player = handler->GetSession()->GetPlayer();
+
+               if (target->HasAuraType(SPELL_AURA_MOD_STEALTH))
+               {
+                       handler->PSendSysMessage("You can't target stealthed players.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (!target)
+               {
+                       handler->PSendSysMessage("Player is not online or does not exist.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (!player->IsSpectator())
+               {
+                       handler->PSendSysMessage("You are not a spectator, spectate someone first.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (target->IsSpectator() && target != player)
+               {
+                       handler->PSendSysMessage("You can't do that. Your target is a spectator.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (player->GetMap() != target->GetMap())
+               {
+                       handler->PSendSysMessage("You can't do that. Your target might be in a different arena match.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               // check for arena preperation
+               // if exists than battle didn`t begin
+               if (target->HasAura(32728) || target->HasAura(32727))
+               {
+                       handler->PSendSysMessage("You can't do that. The Arena match didn't start yet.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               (target == player && player->getSpectateFrom()) ? player->SetViewpoint(player->getSpectateFrom(), false) :
+                       player->SetViewpoint(target, true);
+               return true;
+       }
+
+       static bool HandleSpectateResetCommand(ChatHandler* handler, const char *args)
+       {
+               Player* player = handler->GetSession()->GetPlayer();
+
+               if (!player)
+               {
+                       handler->PSendSysMessage("Cant find player.");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               if (!player->IsSpectator())
+               {
+                       handler->PSendSysMessage("You are not a spectator!");
+                       handler->SetSentErrorMessage(true);
+                       return false;
+               }
+
+               Battleground *bGround = player->GetBattleground();
+               if (!bGround)
+                       return false;
+
+               if (bGround->GetStatus() != STATUS_IN_PROGRESS)
+                       return true;
+
+               for (Battleground::BattlegroundPlayerMap::const_iterator itr = bGround->GetPlayers().begin(); itr != bGround->GetPlayers().end(); ++itr)
+                       if (Player* tmpPlayer = ObjectAccessor::FindPlayer(itr->first))
+                       {
+                               if (tmpPlayer->IsSpectator())
+                                       continue;
+
+                               uint32 tmpID = bGround->GetPlayerTeam(tmpPlayer->GetGUID());
+
+                               // generate addon massage
+                               std::string pName = tmpPlayer->GetName();
+                               std::string tName = "";
+
+                               if (Player *target = tmpPlayer->GetSelectedPlayer())
+                                       tName = target->GetName();
+
+                               SpectatorAddonMsg msg;
+                               msg.SetPlayer(pName);
+                               if (tName != "")
+                                       msg.SetTarget(tName);
+                               msg.SetStatus(tmpPlayer->IsAlive());
+                               msg.SetClass(tmpPlayer->getClass());
+                               msg.SetCurrentHP(tmpPlayer->GetHealth());
+                               msg.SetMaxHP(tmpPlayer->GetMaxHealth());
+                               Powers powerType = tmpPlayer->getPowerType();
+                               msg.SetMaxPower(tmpPlayer->GetMaxPower(powerType));
+                               msg.SetCurrentPower(tmpPlayer->GetPower(powerType));
+                               msg.SetPowerType(powerType);
+                               msg.SetTeam(tmpID);
+                               msg.SendPacket(player->GetGUID());
+                       }
+
+               return true;
+       }
+
+       ChatCommand* GetCommands() const
+       {
+               static ChatCommand spectateCommandTable[] =
+               {
+                       { "player", rbac::RBAC_PERM_COMMAND_SPECTATE_PLAYER, true, &HandleSpectateCommand, "", NULL },
+                       { "view", rbac::RBAC_PERM_COMMAND_SPECTATE_VIEW, true, &HandleSpectateFromCommand, "", NULL },
+                       { "reset", rbac::RBAC_PERM_COMMAND_SPECTATE_RESET, true, &HandleSpectateResetCommand, "", NULL },
+                       { "leave", rbac::RBAC_PERM_COMMAND_SPECTATE_LEAVE, true, &HandleSpectateCancelCommand, "", NULL },
+                       { NULL, 0, false, NULL, "", NULL }
+               };
+
+               static ChatCommand commandTable[] =
+               {
+                       { "spectate", rbac::RBAC_PERM_COMMAND_SPECTATE, false, NULL, "", spectateCommandTable },
+                       { NULL, 0, false, NULL, "", NULL }
+               };
+               return commandTable;
+       }
+};
+
+
+enum NpcSpectatorAtions {
+       // will be used for scrolling
+       NPC_SPECTATOR_ACTION_2V2_GAMES = 2000,
+       NPC_SPECTATOR_ACTION_3V3_GAMES = 3000,
+       NPC_SPECTATOR_ACTION_5V5_GAMES = 1000,
+       NPC_SPECTATOR_ACTION_SPECIFIC = 500,
+
+       // NPC_SPECTATOR_ACTION_SELECTED_PLAYER + player.Guid()
+       NPC_SPECTATOR_ACTION_SELECTED_PLAYER = 4000
+};
+
+const uint8  GamesOnPage = 15;
+
+class npc_arena_spectator : public CreatureScript
+{
+public:
+       npc_arena_spectator() : CreatureScript("npc_arena_spectator") { }
+
+       bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+       {
+               pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface\\icons\\Achievement_Arena_2v2_7:35:35:-30:0|tGames: 2v2", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_2V2_GAMES);
+               pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface\\icons\\Achievement_Arena_3v3_7:35:35:-30:0|tGames: 3v3", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_3V3_GAMES);
+               pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface\\icons\\Achievement_Arena_5v5_7:35:35:-30:0|tGames: 5v5", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_5V5_GAMES);
+               pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "|TInterface\\icons\\Spell_Holy_DevineAegis:35:35:-30:0|tSpectate Specific Player.", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_SPECIFIC, "", 0, true);
+               pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pCreature->GetGUID());
+               return true;
+       }
+
+       bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action)
+       {
+               player->PlayerTalkClass->ClearMenus();
+
+               if (action == NPC_SPECTATOR_ACTION_SPECIFIC)
+               {
+
+               }
+
+               if (action >= NPC_SPECTATOR_ACTION_5V5_GAMES && action < NPC_SPECTATOR_ACTION_2V2_GAMES)
+               {
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, " Refresh", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_5V5_GAMES);
+                       ShowPage(player, action - NPC_SPECTATOR_ACTION_5V5_GAMES, true);
+                       player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+               }
+               else if (action >= NPC_SPECTATOR_ACTION_2V2_GAMES && action < NPC_SPECTATOR_ACTION_3V3_GAMES)
+               {
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Refresh", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_2V2_GAMES);
+                       ShowPage(player, action - NPC_SPECTATOR_ACTION_2V2_GAMES, false);
+                       player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+               }
+               else if (action >= NPC_SPECTATOR_ACTION_3V3_GAMES && action < NPC_SPECTATOR_ACTION_SELECTED_PLAYER)
+               {
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Refresh", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_3V3_GAMES);
+                       ShowPage(player, action - NPC_SPECTATOR_ACTION_3V3_GAMES, true);
+                       player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+               }
+               else
+               {
+
+                       ObjectGuid guid = ObjectGuid(HIGHGUID_PLAYER, action - NPC_SPECTATOR_ACTION_SELECTED_PLAYER);
+                       if (Player* target = ObjectAccessor::FindPlayer(guid))
+                       {
+                               ChatHandler handler(player->GetSession());
+                               char const* pTarget = target->GetName().c_str();
+                               arena_spectator_commands::HandleSpectateCommand(&handler, pTarget);
+                       }
+               }
+               return true;
+       }
+
+       std::string GetClassNameById(uint8 id)
+       {
+               std::string sClass = "";
+               switch (id)
+               {
+               case CLASS_WARRIOR:         sClass = "Warrior ";        break;
+               case CLASS_PALADIN:         sClass = "Paladin ";        break;
+               case CLASS_HUNTER:          sClass = "Hunter ";         break;
+               case CLASS_ROGUE:           sClass = "Rogue ";          break;
+               case CLASS_PRIEST:          sClass = "Priest ";         break;
+               case CLASS_DEATH_KNIGHT:    sClass = "DKnight ";        break;
+               case CLASS_SHAMAN:          sClass = "Shaman ";         break;
+               case CLASS_MAGE:            sClass = "Mage ";           break;
+               case CLASS_WARLOCK:         sClass = "Warlock ";        break;
+               case CLASS_DRUID:           sClass = "Druid ";          break;
+               }
+               return sClass;
+       }
+
+       std::string GetGamesStringData(Battleground* team, uint16 mmr, uint16 mmrTwo)
+       {
+               std::string teamsMember[BG_TEAMS_COUNT];
+               uint32 firstTeamId = 0;
+               for (Battleground::BattlegroundPlayerMap::const_iterator itr = team->GetPlayers().begin(); itr != team->GetPlayers().end(); ++itr)
+                       if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+                       {
+                               if (player->IsSpectator())
+                                       continue;
+
+                               if (player->IsGameMaster())
+                                       continue;
+
+                               uint32 team = itr->second.Team;
+                               if (!firstTeamId)
+                                       firstTeamId = team;
+
+                               teamsMember[firstTeamId == team] += GetClassNameById(player->getClass());
+                       }
+
+               std::string data = teamsMember[0] + "(";
+               std::stringstream ss;
+               std::stringstream sstwo;
+               ss << mmr;
+               sstwo << mmrTwo;
+               data += ss.str();
+               data += ") - ";
+               data += teamsMember[1] + "(" + sstwo.str();
+               data += ")";
+               return data;
+       }
+
+       ObjectGuid GetFirstPlayerGuid(Battleground* team)
+       {
+               for (Battleground::BattlegroundPlayerMap::const_iterator itr = team->GetPlayers().begin(); itr != team->GetPlayers().end(); ++itr)
+                       if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+                               return itr->first;
+               return ObjectGuid::Empty;
+       }
+
+       void ShowPage(Player* player, uint16 page, uint32 IsTop)
+       {              
+               uint32 firstTeamId = 0;
+               uint16 TypeOne = 0;
+               uint16 TypeTwo = 0;
+               uint16 TypeThree = 0;
+               uint16 mmr = 0;
+               uint16 mmrTwo = 0;
+               bool haveNextPage = false;
+               for (uint8 i = 0; i <= MAX_BATTLEGROUND_TYPE_ID; ++i)
+               {
+                       if (!sBattlegroundMgr->IsArenaType(BattlegroundTypeId(i)))
+                               continue;
+
+                       //BattlegroundContainer arenas = sBattlegroundMgr->GetBattlegroundsByType((BattlegroundTypeId)i);
+                       BattlegroundData* arenas = sBattlegroundMgr->GetAllBattlegroundsWithTypeId(BattlegroundTypeId(i));
+
+                       if (!arenas || arenas->m_Battlegrounds.empty())
+                               continue;
+
+                       for (BattlegroundContainer::const_iterator itr = arenas->m_Battlegrounds.begin(); itr != arenas->m_Battlegrounds.end(); ++itr)
+                       {
+                               Battleground* arena = itr->second;
+                               Player* target = ObjectAccessor::FindPlayer(GetFirstPlayerGuid(arena));
+                               if (target && (target->HasAura(32728) || target->HasAura(32727)))
+                                       continue;
+
+                               if (!arena->GetPlayersSize())
+                                       continue;
+
+                               if (arena->GetArenaType() == ARENA_TYPE_2v2)
+                               {
+                                       mmr = arena->GetArenaMatchmakerRating(0);
+                                       firstTeamId = target->GetArenaTeamId(0);
+                                       Battleground::BattlegroundPlayerMap::const_iterator citr = arena->GetPlayers().begin();
+                                       for (; citr != arena->GetPlayers().end(); ++citr)
+                                               if (Player* plrs = sObjectAccessor->FindPlayer(citr->first))
+                                                       if (plrs->GetArenaTeamId(0) != firstTeamId)
+                                                               mmrTwo = arena->GetArenaMatchmakerRating(citr->second.Team);
+                               }
+                               else if (arena->GetArenaType() == ARENA_TYPE_3v3)
+                               {
+                                       mmr = arena->GetArenaMatchmakerRating(1);
+                                       firstTeamId = target->GetArenaTeamId(1);
+                                       Battleground::BattlegroundPlayerMap::const_iterator citr = arena->GetPlayers().begin();
+                                       for (; citr != arena->GetPlayers().end(); ++citr)
+                                               if (Player* plrs = sObjectAccessor->FindPlayer(citr->first))
+                                                       if (plrs->GetArenaTeamId(1) != firstTeamId)
+                                                               mmrTwo = arena->GetArenaMatchmakerRating(citr->second.Team);
+                               }
+                               else if (arena->GetArenaType() == ARENA_TYPE_5v5)
+                               {
+                                       mmr = arena->GetArenaMatchmakerRating(2);
+                                       firstTeamId = target->GetArenaTeamId(2);
+                                       Battleground::BattlegroundPlayerMap::const_iterator citr = arena->GetPlayers().begin();
+                                       for (; citr != arena->GetPlayers().end(); ++citr)
+                                               if (Player* plrs = sObjectAccessor->FindPlayer(citr->first))
+                                                       if (plrs->GetArenaTeamId(2) != firstTeamId)
+                                                               mmrTwo = arena->GetArenaMatchmakerRating(citr->second.Team);
+                               }
+
+                               if (IsTop == 3 && arena->GetArenaType() == ARENA_TYPE_3v3)
+                               {
+                                       TypeThree++;
+                                       if (TypeThree > (page + 1) * GamesOnPage)
+                                       {
+                                               haveNextPage = true;
+                                               break;
+                                       }
+
+                                       if (TypeThree >= page * GamesOnPage)
+                                               player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, GetGamesStringData(arena, mmr, mmrTwo), GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_SELECTED_PLAYER + GetFirstPlayerGuid(arena));
+                               }
+                               else if (IsTop == 2 && arena->GetArenaType() == ARENA_TYPE_2v2)
+                               {
+                                       TypeTwo++;
+                                       if (TypeTwo > (page + 1) * GamesOnPage)
+                                       {
+                                               haveNextPage = true;
+                                               break;
+                                       }
+
+                                       if (TypeTwo >= page * GamesOnPage)
+                                               player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, GetGamesStringData(arena, mmr, mmrTwo), GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_SELECTED_PLAYER + GetFirstPlayerGuid(arena));
+                               }
+                               else if (IsTop == 1 && arena->GetArenaType() == ARENA_TYPE_5v5)
+                               {
+                                       TypeOne++;
+                                       if (TypeOne > (page + 1) * GamesOnPage)
+                                       {
+                                               haveNextPage = true;
+                                               break;
+                                       }
+                                       if (TypeOne >= page * GamesOnPage)
+                                               player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, GetGamesStringData(arena, mmr, mmrTwo), GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_SELECTED_PLAYER + GetFirstPlayerGuid(arena));
+                               }
+                       }
+               }
+
+               if (page > 0)
+               {
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Prev..", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_2V2_GAMES + page - 1);
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Prev..", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_3V3_GAMES + page - 1);
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Prev..", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_5V5_GAMES + page - 1);
+               }
+
+               if (haveNextPage)
+               {
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Next..", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_2V2_GAMES + page + 1);
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Next..", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_3V3_GAMES + page + 1);
+                       player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Next..", GOSSIP_SENDER_MAIN, NPC_SPECTATOR_ACTION_5V5_GAMES + page + 1);
+               }
+       }
+
+       bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code)
+       {
+               if (!player)
+                       return true;
+
+               player->PlayerTalkClass->ClearMenus();
+               player->CLOSE_GOSSIP_MENU();
+               if (sender == GOSSIP_SENDER_MAIN)
+               {
+                       switch (action)
+                       {
+                       case NPC_SPECTATOR_ACTION_SPECIFIC: // choosing a player
+
+                               const char* plrName = code;
+
+                               char playerName[50];
+                               strcpy(playerName, plrName);
+
+                               for (int i = 0; i < 13; i++)
+                               {
+                                       if (playerName[i] == NULL)
+                                               break;
+                                       if (i == 0 && playerName[i] > 96)
+                                               playerName[0] -= 32;
+                                       else if (playerName[i] < 97)
+                                               playerName[i] += 32;
+                               }
+
+                               if (Player* target = sObjectAccessor->FindPlayerByName(playerName))
+                               {
+                                       ChatHandler handler(player->GetSession());
+                                       char const* pTarget = target->GetName().c_str();
+                                       arena_spectator_commands::HandleSpectateCommand(&handler, pTarget);
+                               }
+                               ChatHandler(player->GetSession()).PSendSysMessage("Player is not online or does not exist.");
+                               return true;
+                       }
+               }
+
+               return false;
+       }
+};
+
+
+void AddSC_arena_spectator_script()
+{
+       new arena_spectator_commands();
+       new npc_arena_spectator();
+}
diff --git a/src/server/scripts/Custom/ArenaSpectator/sql/Arena Spectator NPC.sql b/src/server/scripts/Custom/ArenaSpectator/sql/Arena Spectator NPC.sql
new file mode 100644
index 0000000..2f4aed5
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaSpectator/sql/Arena Spectator NPC.sql     
@@ -0,0 +1,10 @@
+SET
+@Entry = 190000,
+@Name = "Arena Spectator",
+@Subname = "Spectate Master",
+@IconName = "Speak";
+
+DELETE FROM `creature_template` WHERE `entry`=@Entry;
+INSERT INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `scale`, `rank`, `dmgschool`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(@Entry, 29348, 0, @Name, @Subname, @IconName, 0, 80, 80, 2, 35, 3, 1, 0, 0, 2000, 0, 1, 0, 7, 138936390, 0, 0, 0, '', 0, 3, 1, 0, 0, 1, 0, 0, 'npc_arena_spectator');
+
diff --git a/src/server/scripts/Custom/ArenaSpectator/sql/rbac_linked_permissions.sql b/src/server/scripts/Custom/ArenaSpectator/sql/rbac_linked_permissions.sql
new file mode 100644
index 0000000..04f0aaf
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaSpectator/sql/rbac_linked_permissions.sql
@@ -0,0 +1,6 @@
+insert into `rbac_linked_permissions` (`id`, `linkedId`) values
+('195','1003'),
+('195','1004'),
+('195','1005'),
+('195','1006'),
+('195','1007');
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaSpectator/sql/rbac_permissions.sql b/src/server/scripts/Custom/ArenaSpectator/sql/rbac_permissions.sql
new file mode 100644
index 0000000..baba4bd
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaSpectator/sql/rbac_permissions.sql
@@ -0,0 +1,6 @@
+insert into `rbac_permissions` (`id`, `name`) values
+('1003', 'spectate'),
+('1004', 'spectate player'),
+('1005', 'spectate view'),
+('1006', 'spectate reset'),
+('1007', 'spectate leave');
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 5218f76..7db4bc6 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -12,7 +12,8 @@
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
-#  ${sources_Custom}
+  Custom/ArenaSpectator/arena_spectator.cpp
+
 )
 
 message("  -> Prepared: Custom")
--
1.9.4.msysgit.0
